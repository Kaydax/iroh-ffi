namespace iroh {
  void set_log_level(LogLevel level);
};

enum LogLevel {
  "Trace",
  "Debug",
  "Info",
  "Warn",
  "Error",
  "Off",
};

interface IrohNode {
  [Throws=IrohError]
  constructor();
  string peer_id();
  [Throws=IrohError]
  Doc create_doc();
  [Throws=IrohError]
  Doc import_doc(DocTicket ticket);
  [Throws=IrohError]
  AuthorId create_author();
  [Throws=IrohError]
  record<string, CounterStats> stats();
};

interface Doc {
  string id();
  [Throws=IrohError]
  DocTicket share_write();
  [Throws=IrohError]
  DocTicket share_read();
  [Throws=IrohError]
  Hash set_bytes(AuthorId author, bytes key, bytes value);
  [Throws=IrohError]
  bytes get_content_bytes(Hash hash);
  [Throws=IrohError]
  sequence<Entry> latest();
  [Throws=IrohError]
  void subscribe(SubscribeCallback cb);
  [Throws=IrohError]
  void stop_sync();
  [Throws=IrohError]
  LiveStatus status();
};

callback interface SubscribeCallback {
  [Throws=IrohError]
  void event(LiveEvent event);
};

interface AuthorId {
  string to_string();
};

interface Entry {
  AuthorId author();
  bytes key();
  Hash hash();
};

interface Hash {
  string to_string();
  bytes to_bytes();
};

interface DocTicket {
  [Name=from_string, Throws=IrohError]
  constructor(string content);
  string to_string();
};

dictionary LiveStatus {
  boolean active;
  u64 subscriptions;
};

dictionary CounterStats {
  u64 value;
  string description;
};

[Enum]
interface LiveEvent {
  InsertLocal();
  InsertRemote();
  ContentReady();
};

[Error]
interface IrohError {
  Runtime(string description);
  NodeCreate(string description);
  Doc(string description);
  Author(string description);
  DocTicket(string description);
  Uniffi(string description);
};
